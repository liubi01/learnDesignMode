# 高阶函数
1.  函数可以作为参数被传递；
2.  函数可以作为返回值输出。

## 实现AOP

::: 跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，
再通过“动态织入”的方式掺入业务逻辑模块中

```javascript
  Function.prototype.before = function(beforefn) {
      var __self = this; // 保存原函数的引用
      return function() { // 返回包含了原函数和新函数的"代理"函数
          beforefn.apply(this, arguments); // 执行新函数，修正 this 
          return __self.apply(this, arguments); // 执行原函数
      }
  };
  Function.prototype.after = function(afterfn) {
      var __self = this;
      return function() {
          var ret = __self.apply(this, arguments);
          afterfn.apply(this, arguments);
          return ret;
      }
  };
  var func = function() {
      console.log(2);
  };
  func = func.before(function() {
      console.log(1);
  }).after(function() {
      console.log(3);
  });
  func();
```

## 其他高阶函数应用

### 函数柯里化

::: 函数传值不会立马计算，而是会通过闭包把值存储，并可以继续传值，待到函数被真正求值才会吧所有参数一次性求值

1. 应用场景：假设我们要编写一个计算每月开销的函数。在每天结束之前，我们都要记录今天花掉了多少
钱。

```javascript
  var currying = function(fn) {
      var args = [];
      return function() {
          if (arguments.length === 0) {
              return fn.apply(this, args);
          } else {
              [].push.apply(args, arguments);
              return arguments.callee;
          }
      }
  };
  var cost = (function() {
      var money = 0;
      return function() {
          for (var i = 0, l = arguments.length; i < l; i++) {
              money += arguments[i];
          }
          return money;
      }
  })();
  var cost = currying(cost); // 转化成 currying 函数
  cost(100); // 未真正求值
  cost(200); // 未真正求值 
  cost(300); // 未真正求值
  alert(cost()); // 求值并输出：600
```
### uncurrying

::: 泛化 this 的过程提取出来
